DROP TABLE IF EXISTS user_data, film_comment, serie_comment, watchlist, watchlist_comment CASCADE;

CREATE TABLE user_data (
    user_id integer GENERATED BY DEFAULT AS IDENTITY,
    username character varying(25) NOT NULL,
    hashed_password bytea NOT NULL,
    CONSTRAINT pk_user_data PRIMARY KEY (user_id)
);

CREATE TABLE film_comment (
    film_comment_id integer GENERATED BY DEFAULT AS IDENTITY,
    comment_text character varying(10000) NOT NULL,
    publish_date date NOT NULL DEFAULT (CURRENT_DATE),
    tmdb_film_id integer NOT NULL,
    user_id integer NOT NULL,
    CONSTRAINT pk_film_comment PRIMARY KEY (film_comment_id), 
    CONSTRAINT fk_user_film_comment FOREIGN KEY (user_id) REFERENCES user_data (user_id) ON DELETE CASCADE
);

CREATE TABLE serie_comment (
    serie_comment_id integer GENERATED BY DEFAULT AS IDENTITY,
    comment_text character varying(10000) NOT NULL,
    publish_date date NOT NULL DEFAULT (CURRENT_DATE),
    tmdb_serie_id integer NOT NULL,
    user_id integer NOT NULL,
    CONSTRAINT pk_serie_comment PRIMARY KEY (serie_comment_id),
    CONSTRAINT fk_user_serie_comment FOREIGN KEY (user_id) REFERENCES user_data (user_id) ON DELETE CASCADE
);

CREATE TABLE "UserUser" (
    "FollowersId" integer NOT NULL,
    "UsersFollowedId" integer NOT NULL,
    CONSTRAINT "PK_UserUser" PRIMARY KEY ("FollowersId", "UsersFollowedId"),
    CONSTRAINT "FK_UserUser_user_data_FollowersId" FOREIGN KEY ("FollowersId") REFERENCES user_data (user_id) ON DELETE CASCADE,
    CONSTRAINT "FK_UserUser_user_data_UsersFollowedId" FOREIGN KEY ("UsersFollowedId") REFERENCES user_data (user_id) ON DELETE CASCADE
);

CREATE TABLE watchlist (
    watchlist_id integer GENERATED BY DEFAULT AS IDENTITY,
    watchlist_title character varying(200) NOT NULL,
    watchlist_description character varying(20000) NOT NULL,
    publish_date date NOT NULL DEFAULT (CURRENT_DATE),
    poster_paths character varying(200)[] NOT NULL,
    watchlist_films_ids integer[] NOT NULL,
    watchlist_series_ids integer[] NOT NULL,
    user_id integer NOT NULL,
    CONSTRAINT pk_watchlist PRIMARY KEY (watchlist_id),
    CONSTRAINT fk_user_watchlist FOREIGN KEY (user_id) REFERENCES user_data (user_id) ON DELETE CASCADE
);

CREATE TABLE watchlist_comment (
    watchlist_comment_id integer GENERATED BY DEFAULT AS IDENTITY,
    comment_text character varying(10000) NOT NULL,
    publish_date date NOT NULL DEFAULT (CURRENT_DATE),
    watchlist_id integer NOT NULL,
    user_id integer NOT NULL,
    CONSTRAINT pk_watchlist_comment PRIMARY KEY (watchlist_comment_id),
    CONSTRAINT fk_watchlist_comment_user_data_user_id FOREIGN KEY (user_id) REFERENCES user_data (user_id) ON DELETE CASCADE,
    CONSTRAINT fk_watchlist_comment FOREIGN KEY (watchlist_id) REFERENCES watchlist (watchlist_id) ON DELETE CASCADE
);

CREATE INDEX ix_film_comment_tmdb_film_id ON film_comment (tmdb_film_id);

CREATE INDEX ix_film_comment_user_id ON film_comment (user_id);

CREATE INDEX ix_serie_comment_tmdb_serie_id ON serie_comment (tmdb_serie_id);

CREATE INDEX ix_serie_comment_user_id ON serie_comment (user_id);

CREATE UNIQUE INDEX ix_user_data_username ON user_data (username);

CREATE INDEX ix_UserUser_UsersFollowedId ON "UserUser" ("UsersFollowedId");

CREATE INDEX ix_watchlist_user_id ON watchlist (user_id);

CREATE INDEX ix_watchlist_comment_user_id ON watchlist_comment (user_id);

CREATE INDEX ix_watchlist_comment_watchlist_id ON watchlist_comment (watchlist_id);

CREATE VIEW all_comments AS
  SELECT user_id, comment_text, 'film'::varchar(10) AS commented_object, tmdb_film_id FROM film_comment
    UNION
  SELECT user_id, comment_text, 'serie'::varchar(10) AS commented_object, tmdb_serie_id FROM serie_comment;

-- Connect view to ef core :
-- https://learn.microsoft.com/en-us/ef/core/modeling/keyless-entity-types?tabs=data-annotations

CREATE EXTENSION IF NOT EXISTS pg_trgm;

CREATE OR REPLACE FUNCTION search_watchlists(search_text varchar(200))
RETURNS SETOF watchlist AS $$
    SELECT watchlist_id, watchlist_title, watchlist_description, publish_date, poster_paths, watchlist_films_ids, watchlist_series_ids, user_id
    FROM (
        SELECT *, similarity(watchlist_title, search_text) AS similarity
        FROM watchlist
    )
	WHERE similarity > 0.1
    ORDER BY similarity DESC
    LIMIT 10;
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION search_username(search_text varchar(200))
RETURNS SETOF user_data AS $$
    SELECT user_id, username, hashed_password
    FROM (
        SELECT *, similarity(username, search_text) AS similarity
        FROM user_data
    )
	WHERE similarity > 0.2
    ORDER BY similarity DESC
    LIMIT 10;
$$ LANGUAGE sql;
